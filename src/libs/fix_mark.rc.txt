// src/libs/fix_mark.rs

use std::fs::{self, File};
use std::io::{BufWriter, Write};
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

pub async fn run(dir: &str) {
    println!("🔧 --fix-mark: Auditing and patching .mark files at {}", dir);

    let mark_root = Path::new(dir).join(".mark");
    let mut fixed = 0;

    let mstp_path = mark_root.join("mark.mstp");
    let Ok(lines) = fs::read_to_string(&mstp_path) else {
        println!("❌ Could not read mark.mstp");
        return;
    };

    let paths: Vec<PathBuf> = lines
        .lines()
        .filter(|l| l.trim().starts_with("- "))
        .map(|l| mark_root.join(l.trim().trim_start_matches("- ").trim()))
        .collect();

    for path in paths {
        if path.exists() {
            continue;
        }

        let parent = path.parent().unwrap();
        let filename = path.file_name().unwrap().to_str().unwrap();

        if filename.starts_with("marks.") {
            fs::create_dir_all(parent).unwrap();
            let content = format!("# Task: AutoGenerated\n\n## Description\nPlaceholder for {}\n", filename);
            fs::write(&path, content).unwrap();
            println!("🧠 Created missing mark: {}", path.display());
            fixed += 1;
        } else if filename.starts_with("markers.") {
            fs::create_dir_all(parent).unwrap();
            let content = format!("# Marker: AutoGenerated\n\n## Trigger\nUnknown\n\n## Effect\nUnknown\n");
            fs::write(&path, content).unwrap();
            println!("🔖 Created missing marker: {}", path.display());
            fixed += 1;
        } else if filename.starts_with("md.") {
            fs::create_dir_all(parent).unwrap();
            let content = format!("# Identity: {}\n\n## Summary\nAutogenerated .md file\n", filename);
            fs::write(&path, content).unwrap();
            println!("📘 Created missing metadata: {}", path.display());
            fixed += 1;
        }
    }

    println!("✅ --fix-mark complete. {} missing files patched.\n", fixed);
}
